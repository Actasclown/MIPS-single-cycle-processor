

00400020 / 00002820; ADD $5 $0 $0 // $5 = 0
00400024 / 20071000; ADDI $7 $0 0x1000 // $7 = 0x1000
00400028 / 00e73c00; SLL $7 $7 0x10 // $7 = 0x1000 << 16 = 0x10000000
0040002c / 00e03020; ADD $6 $7 $0 // $6 = 0x10000000
00400030 / 20c60028; ADDI $6 $6 0x28 // $6 = 0x10000028
00400034 / 8ce40000; * LW $4 0x0($7) // load data at MEM[$7] to $4 
00400038 / 00a42821; ADDU $5 $5 $4 // $5 += $4
0040003c / 20e70004; ADDI $7 $7 0x4 // $7 = 0x10000004
00400040 / 14e6fffc; BNE $7 $6 0xFFFC // goto * if $7 == $6
00400044 / ace50000;  SW $5 0x0($7) // at last $5 = 0xefffffff; store it to 10000028


10000000 / 0000000f; $7 = 10000000 $5 = 0xf $7 = 10000004
10000004 / 000000f0; $7 = 10000004 $5 = 0xff  
10000008 / 00000f00; $5 = 0xfff
1000000c / 0000f000; $5 = 0xffff
10000010 / 000f0000; $5 = 0xfffff
10000014 / 00f00000; $5 = 0xffffff
10000018 / 0f000000; $5 = 0xfffffff
1000001c / 10000000; $5 = 0x1fffffff
10000020 / 20000000; $5 = 0x2fffffff 
10000024 / c0000000; $5 = 0xefffffff $7=10000028
10000028 / ffffffff; 
